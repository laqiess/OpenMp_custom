
#include <omp.h>
#include <random>
// author:  лючерев јртем

#include "PiCircle.h"

/*
* ¬ычисление числа ѕи методом ћонте- арло
1)ѕредставьте себе квадрат со стороной длиной 1 единица.
2)¬нутри этого квадрата вписан круг с радиусом 0.5 единицы.
3)“еперь представьте, что вы случайным образом бросаете точки внутри этого квадрата.
4)Ќекоторые из этих точек попадут внутрь круга, а некоторые - за его пределы.
5)ќтношение количества точек, попавших внутрь круга, к общему количеству точек, 
брошенных внутрь квадрата, будет приближатьс€ к значению ѕи/4.
*/

// функци€ дл€ вычислени€ значени€ pi, использу€ библиотеку OpenMP
double count_pi_parallel(const int num_points) {

    int num_inside = 0;

    // parallel - опредл€ет код, который будет параллельно выполн€тьс€ несколькими потоками
    // for - распараллеливание цикла
    // reduction(+:num_inside) - здесь + это операци€, num_inside - обща€ переменна€, 
    // локальный экземпл€р которой создаЄтс€ дл€ каждого потока
    // reduction решает проблему, св€занную с неопределЄнностью параллелизма
#pragma omp parallel for reduction(+:num_inside)
    for (int i = 0; i < num_points; ++i) {
        //генерируютс€ две случайные координаты x и y в диапазоне от 0 до 1.
        double x = (double)rand() / RAND_MAX;
        double y = (double)rand() / RAND_MAX;

        //cout << x << " " << y << endl;
        //Ёта часть кода провер€ет,
        //попадает ли сгенерированна€ точка (x, y) внутрь единичного круга, центр которого находитс€ в начале координат.
        if (x * x + y * y <= 1) {
            num_inside++;
        }
    }
    //пи=4*(кол-во точек внутри круга/на общее количество точек)
    double pi = 4.0 * ((double)num_inside / num_points);
    return pi;
}

// функци€ дл€ вычислени€ значени€ pi в одном потоке
double count_pi(const int num_points) {

    int num_inside = 0;
    double x, y;

    for (int i = 0; i < num_points; ++i) {
        //генерируютс€ две случайные координаты x и y в диапазоне от 0 до 1.
        x = (double)rand() / RAND_MAX;
        y = (double)rand() / RAND_MAX;

        //cout << x << " " << y << endl;

        //Ёта часть кода провер€ет,
        //попадает ли сгенерированна€ точка (x, y) внутрь единичного круга, центр которого находитс€ в начале координат.
        if (x * x + y * y <= 1) {
            num_inside++;
        }
    }
    //пи=4*(кол-во точек внутри круга/на общее количество точек)
    double pi = 4.0 * ((double)num_inside / num_points);
    return pi;
}
// функци€ дл€ вычислени€ значени€ pi, использу€ библиотеку OpenMP
double count_pi_parallel(const int num_points);

// функци€ дл€ вычислени€ значени€ pi в одном потоке
double count_pi(const int num_points);

